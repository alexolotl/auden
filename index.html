<!DOCTYPE html>
<html>
<head>
    <title>Virtual Gallery</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
        }
        body {
            background-color: #ffffff;
            margin: 0;
            overflow: hidden;
            font-family: arial;
        }
    </style>
</head>
<body>
        <div id="prompt"></div>
        <div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank"></a>Loading...</a></div>

		<script src="js/three.min.js"></script>
        <script src="js/OrbitControls.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

    
    <script id="vertexShader2" type="x-shader/x-vertex">

        #define M_PI 3.1415926535897932384626433832795

        varying vec3 vNormal;
        varying vec2 vUv;
        varying vec4 vReflection;
        uniform float time;
        uniform vec2 mouse;
        uniform vec2 resolution;
        uniform float scale;

        vec3 parametric(float newu, float newv) {
            vec3 newValue;
            newValue.x = sin(newu)*cos(newv);
            newValue.y = sin(newu)*sin(newv);
            newValue.z = cos(newu);

            vec3 normVal = normalize(newValue);
            
            vec3 displacement = normVal*vec3(
              0.5*(0.5*sin(1.0*normVal.y+time)+0.5),
              0.4*(0.5*sin(1.432*normVal.z+time)+0.5),
              0.35*(0.5*sin(0.5235*normVal.x+time)+0.5));
            return newValue + (0.5*sin(M_PI-M_PI/2.0)+0.5)*displacement;
        }
      
        void main()	{
            vUv = uv;

            vec2 nMouse = mouse / resolution.xy;

            vUv.x = uv.x * M_PI;
            vUv.y = uv.y * M_PI*2.0;

            vec3 newPosition = parametric(vUv.x, vUv.y);

            float smallvalue = 0.01;

            vec3 neighbor1 = parametric(vUv.x+smallvalue, vUv.y);
            vec3 neighbor2 = parametric(vUv.x, vUv.y+smallvalue);

            vec3 tangent = neighbor1 - newPosition;
            vec3 bitangent = neighbor2 - newPosition;

            vNormal = normalize(cross(tangent, bitangent));

            vReflection = reflect(-normalize(modelMatrix*vec4(newPosition,1.0) - vec4(cameraPosition,1.0)), vec4(vNormal,0.0));

            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
        }

		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">

            #define M_PI 3.1415926535897932384626433832795

			uniform vec2 resolution;
            uniform float time;
            uniform samplerCube uTexCube;
            varying vec3 vNormal;
            varying vec2 vUv;
            varying vec4 vReflection;

            void main()	{
                vec2 p = vUv;
                p.x = p.x / M_PI;
                p.y = p.y / M_PI / 2.0;

                vec3 light = vec3(0.5*sin(time/10.)+0.5, 0.5+sin(time/6.)+0.5, 1.0);
                vec3 light2 = vec3(-1.0 -0.5*cos(time/10.)+0.5, -2.0 + 2.0*(-0.5+sin(time/4.)+0.5), -1. + 2.*sin(time/5.));
                light = normalize(light);
                light2 = normalize(light2);
                float strength = 0.7;

                float dProd = (pow(max(0.0,dot(vNormal, light)),12.0) + pow(max(0.0,dot(vNormal, light2)),12.0)) * strength;

                vec2 r = p;
                vec3 ambient = vec3(0.0,0.0,0.3);
                ambient = textureCube(uTexCube, -normalize(vReflection.xyz)).xyz;

                gl_FragColor= vec4(vec3(dProd)+ambient,1.0);
             }

    </script>
    
    <script id="fragmentShaderTexture" type="x-shader/x-fragment">
    
            uniform vec2 resolution;
			uniform float time;
            varying vec2 vUv;
    
    //  Simplex 3D Noise Function
    //  by Ian McEwan, Ashima Arts
    //
    vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
    vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

    float noise(vec3 v){ 
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

    // First corner
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;

    // Other corners
      vec3 g = step(x0.yzx, x0.xyz);
      vec3 l = 1.0 - g;
      vec3 i1 = min( g.xyz, l.zxy );
      vec3 i2 = max( g.xyz, l.zxy );

      //  x0 = x0 - 0. + 0.0 * C 
      vec3 x1 = x0 - i1 + 1.0 * C.xxx;
      vec3 x2 = x0 - i2 + 2.0 * C.xxx;
      vec3 x3 = x0 - 1. + 3.0 * C.xxx;

    // Permutations
      i = mod(i, 289.0 ); 
      vec4 p = permute( permute( permute( 
                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
               + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
               + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

    // Gradients
    // ( N*N points uniformly over a square, mapped onto an octahedron.)
      float n_ = 1.0/7.0; // N=7
      vec3  ns = n_ * D.wyz - D.xzx;

      vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

      vec4 x_ = floor(j * ns.z);
      vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

      vec4 x = x_ *ns.x + ns.yyyy;
      vec4 y = y_ *ns.x + ns.yyyy;
      vec4 h = 1.0 - abs(x) - abs(y);

      vec4 b0 = vec4( x.xy, y.xy );
      vec4 b1 = vec4( x.zw, y.zw );

      vec4 s0 = floor(b0)*2.0 + 1.0;
      vec4 s1 = floor(b1)*2.0 + 1.0;
      vec4 sh = -step(h, vec4(0.0));

      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

      vec3 p0 = vec3(a0.xy,h.x);
      vec3 p1 = vec3(a0.zw,h.y);
      vec3 p2 = vec3(a1.xy,h.z);
      vec3 p3 = vec3(a1.zw,h.w);

    //Normalise gradients
      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
      p0 *= norm.x;
      p1 *= norm.y;
      p2 *= norm.z;
      p3 *= norm.w;

    // Mix final noise value
      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
      m = m * m;
      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                    dot(p2,x2), dot(p3,x3) ) );
    }

    #define NUM_OCTAVES 2

    float fbm(vec3 x) {
        float v = 0.0;
        float a = 0.5;
        vec3 shift = vec3(100);
        for (int i = 0; i < NUM_OCTAVES; ++i) {
            v += a * noise(x);
            x = x * 2.0 + shift;
            a *= 0.5;
        }
        return v;
    }
    
    mat2 rotate2d(in float _angle) {
        return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle));
    }

    void main()
    {
        vec2 st = vUv.xy;

        st = mix(st,rotate2d(3.14*fbm(vec3(st/20.,time/18.)))*(st+5.*vec2(fbm(vec3(st+vec2(4.8,16.3),time/8.)),fbm(vec3(st+vec2(2.3,12.3),time/7.)))),0.1);

        vec2 q = vec2( fbm(vec3(st,time/8.)), fbm(vec3(st+vec2(2.8,16.5),4.3 + time/8.)) );
        vec2 r = vec2( fbm(vec3(st + q,time/4.)), fbm(vec3(st + q +vec2(7.8,24.5),15.2 +time/4.)) );
        float color = fbm( vec3(st + 1.5*r,time/2.));

        vec3 color1 = mix(vec3(0.,0.6,0.7),vec3(0.4,0.1,0.2),color);
        vec3 color2 = mix(vec3(.7,.1,.3),vec3(.6,.9,.9),length(r));
        vec3 colorBands = smoothstep(0.8,1.0,color1);
        vec3 color3 = mix(color1,vec3(0.9,0.8,0.2),r.x);
        vec3 color4 = mix(color3,color2*colorBands,color/4.);

        gl_FragColor = vec4(color4*color2*2.+colorBands, 1.0); //just taking vec3(color) gives nice black/white version
    }
    </script>
    
    
    
    
    <script id="vertexShader0" type="x-shader/x-vertex">

        #define M_PI 3.1415926535897932384626433832795

        varying vec3 vNormal;
        varying vec2 vUv;
        varying vec4 vReflection;
        varying float vColor;
        varying vec2 vR;
        uniform float time;
        uniform vec2 mouse;
        uniform vec2 resolution;
        uniform float scale;
        
        
        
        
        
        
        
        //  Simplex 3D Noise Function
    //  by Ian McEwan, Ashima Arts
    //
    vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
    vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

    float noise(vec3 v){ 
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

    // First corner
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;

    // Other corners
      vec3 g = step(x0.yzx, x0.xyz);
      vec3 l = 1.0 - g;
      vec3 i1 = min( g.xyz, l.zxy );
      vec3 i2 = max( g.xyz, l.zxy );

      //  x0 = x0 - 0. + 0.0 * C 
      vec3 x1 = x0 - i1 + 1.0 * C.xxx;
      vec3 x2 = x0 - i2 + 2.0 * C.xxx;
      vec3 x3 = x0 - 1. + 3.0 * C.xxx;

    // Permutations
      i = mod(i, 289.0 ); 
      vec4 p = permute( permute( permute( 
                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
               + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
               + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

    // Gradients
    // ( N*N points uniformly over a square, mapped onto an octahedron.)
      float n_ = 1.0/7.0; // N=7
      vec3  ns = n_ * D.wyz - D.xzx;

      vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

      vec4 x_ = floor(j * ns.z);
      vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

      vec4 x = x_ *ns.x + ns.yyyy;
      vec4 y = y_ *ns.x + ns.yyyy;
      vec4 h = 1.0 - abs(x) - abs(y);

      vec4 b0 = vec4( x.xy, y.xy );
      vec4 b1 = vec4( x.zw, y.zw );

      vec4 s0 = floor(b0)*2.0 + 1.0;
      vec4 s1 = floor(b1)*2.0 + 1.0;
      vec4 sh = -step(h, vec4(0.0));

      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

      vec3 p0 = vec3(a0.xy,h.x);
      vec3 p1 = vec3(a0.zw,h.y);
      vec3 p2 = vec3(a1.xy,h.z);
      vec3 p3 = vec3(a1.zw,h.w);

    //Normalise gradients
      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
      p0 *= norm.x;
      p1 *= norm.y;
      p2 *= norm.z;
      p3 *= norm.w;

    // Mix final noise value
      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
      m = m * m;
      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                    dot(p2,x2), dot(p3,x3) ) );
    }

    #define NUM_OCTAVES 2

    float fbm(vec3 x) {
        float v = 0.0;
        float a = 0.5;
        vec3 shift = vec3(100);
        for (int i = 0; i < NUM_OCTAVES; ++i) {
            v += a * noise(x);
            x = x * 2.0 + shift;
            a *= 0.5;
        }
        return v;
    }
    
    mat2 rotate2d(in float _angle) {
        return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle));
    }
        
        
        
        
        

        vec3 parametric(float newu, float newv) {
            vec3 newValue;
            newValue.x = sin(newu)*cos(newv);
            newValue.y = sin(newu)*sin(newv);
            newValue.z = cos(newu);

            vec3 normVal = normalize(newValue);
            
            //vec3 displacement = normVal*vec3(
            //  0.5*(0.5*sin(1.0*normVal.y+time)+0.5),
            //  0.4*(0.5*sin(1.432*normVal.z+time)+0.5),
            //  0.35*(0.5*sin(0.5235*normVal.x+time)+0.5));
              
            vec3 displacement = normVal*vec3((1.0-vColor) + 5.0); // 5 to 6 range
            return newValue + (0.5*sin(M_PI-M_PI/2.0)+0.5)*displacement;
        }
      
        void main()	{
            vUv = uv;
            
            
            
            vec2 st = vUv.xy;

            st = mix(st,rotate2d(3.14*fbm(vec3(st/20.,time/18.)))*(st+5.*vec2(fbm(vec3(st+vec2(4.8,16.3),time/8.)),fbm(vec3(st+vec2(2.3,12.3),time/7.)))),0.1);

            vec2 q = vec2( fbm(vec3(st,time/8.)), fbm(vec3(st+vec2(2.8,16.5),4.3 + time/8.)) );
            vec2 r = vec2( fbm(vec3(st + q,time/4.)), fbm(vec3(st + q +vec2(7.8,24.5),15.2 +time/4.)) );
            float color = fbm( vec3(st + 1.5*r,time/2.));
            vColor = color;
            vR = r;
            
            

            vec2 nMouse = mouse / resolution.xy;

            vUv.x = uv.x * M_PI;
            vUv.y = uv.y * M_PI*2.0;

            vec3 newPosition = parametric(vUv.x, vUv.y);

            float smallvalue = 0.01;

            vec3 neighbor1 = parametric(vUv.x+smallvalue, vUv.y);
            vec3 neighbor2 = parametric(vUv.x, vUv.y+smallvalue);

            vec3 tangent = neighbor1 - newPosition;
            vec3 bitangent = neighbor2 - newPosition;

            vNormal = normalize(cross(tangent, bitangent));

            vReflection = reflect(-normalize(modelMatrix*vec4(newPosition,1.0) - vec4(cameraPosition,1.0)), vec4(vNormal,0.0));

            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
        }

		</script>
    <script id="fragmentShader0" type="x-shader/x-fragment">
    
            uniform vec2 resolution;
			uniform float time;
            varying vec2 vUv;
            varying float vColor;
            varying vec2 vR;

    void main()
    {
        float color = vColor;
        vec2 r = vR;

        vec3 color1 = mix(vec3(0.,0.6,0.7),vec3(0.4,0.1,0.2),color);
        vec3 color2 = mix(vec3(.7,.1,.3),vec3(.6,.9,.9),length(r));
        vec3 colorBands = smoothstep(0.8,1.0,color1);
        vec3 color3 = mix(color1,vec3(0.9,0.8,0.2),r.x);
        vec3 color4 = mix(color3,color2*colorBands,color/4.);

        gl_FragColor = vec4(color4*color2*2.+colorBands, 1.0); //just taking vec3(color) gives nice black/white version
        //gl_FragColor = vec4(vec3(color), 1.0);
    }
    </script>
    
    
    
    <script id="vertexShader3" type="x-shader/x-vertex">

        #define M_PI 3.1415926535897932384626433832795

        varying vec3 vNormal;
        varying vec2 vUv;
        varying vec4 vReflection;
        varying float vColor;
        varying vec2 vR;
        uniform float time;
        uniform vec2 mouse;
        uniform vec2 resolution;
        uniform float scale;
        
        
        
        
        
        
        
        //  Simplex 3D Noise Function
    //  by Ian McEwan, Ashima Arts
    //
    vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
    vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

    float noise(vec3 v){ 
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

    // First corner
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;

    // Other corners
      vec3 g = step(x0.yzx, x0.xyz);
      vec3 l = 1.0 - g;
      vec3 i1 = min( g.xyz, l.zxy );
      vec3 i2 = max( g.xyz, l.zxy );

      //  x0 = x0 - 0. + 0.0 * C 
      vec3 x1 = x0 - i1 + 1.0 * C.xxx;
      vec3 x2 = x0 - i2 + 2.0 * C.xxx;
      vec3 x3 = x0 - 1. + 3.0 * C.xxx;

    // Permutations
      i = mod(i, 289.0 ); 
      vec4 p = permute( permute( permute( 
                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
               + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
               + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

    // Gradients
    // ( N*N points uniformly over a square, mapped onto an octahedron.)
      float n_ = 1.0/7.0; // N=7
      vec3  ns = n_ * D.wyz - D.xzx;

      vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

      vec4 x_ = floor(j * ns.z);
      vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

      vec4 x = x_ *ns.x + ns.yyyy;
      vec4 y = y_ *ns.x + ns.yyyy;
      vec4 h = 1.0 - abs(x) - abs(y);

      vec4 b0 = vec4( x.xy, y.xy );
      vec4 b1 = vec4( x.zw, y.zw );

      vec4 s0 = floor(b0)*2.0 + 1.0;
      vec4 s1 = floor(b1)*2.0 + 1.0;
      vec4 sh = -step(h, vec4(0.0));

      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

      vec3 p0 = vec3(a0.xy,h.x);
      vec3 p1 = vec3(a0.zw,h.y);
      vec3 p2 = vec3(a1.xy,h.z);
      vec3 p3 = vec3(a1.zw,h.w);

    //Normalise gradients
      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
      p0 *= norm.x;
      p1 *= norm.y;
      p2 *= norm.z;
      p3 *= norm.w;

    // Mix final noise value
      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
      m = m * m;
      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                    dot(p2,x2), dot(p3,x3) ) );
    }

    #define NUM_OCTAVES 2

    float fbm(vec3 x) {
        float v = 0.0;
        float a = 0.5;
        vec3 shift = vec3(100);
        for (int i = 0; i < NUM_OCTAVES; ++i) {
            v += a * noise(x);
            x = x * 2.0 + shift;
            a *= 0.5;
        }
        return v;
    }
    
    mat2 rotate2d(in float _angle) {
        return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle));
    }
        
        
        
        
        


      
        void main()	{
            vUv = uv;
            
            vec2 st = 0.5*vUv.xy;
            
            vUv = st;
            

            st = mix(st,rotate2d(M_PI*fbm(vec3(st/20.,time/18.)))*(st+5.*vec2(fbm(vec3(st+vec2(4.8,16.3),time/12.)),fbm(vec3(st+vec2(2.3,12.3),time/9.)))),0.1);

            vec2 q = vec2( fbm(vec3(st,time/16.)), fbm(vec3(st+vec2(2.8,16.5),4.3 + time/12.)) );
            vec2 r = vec2( fbm(vec3(st + q,time/8.)), fbm(vec3(st + q +vec2(7.8,24.5),15.2 +time/8.)) );
            float color = fbm( vec3(st + 1.5*r,time/4.));
            vColor = color;
            vR = r;
            
            vec3 normVal = normalize(position);
            
            
            
            vec3 displacement = normVal*vec3((vColor)*2.0 + 3.0) * sin(uv.x*M_PI) * sin(uv.y*M_PI);
            displacement.y *= 1.5;
            
            vec3 newPosition = position + displacement;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
        }

		</script>
    <script id="fragmentShader3" type="x-shader/x-fragment">
    
            uniform vec2 resolution;
			uniform float time;
            varying vec2 vUv;
            varying float vColor;
            varying vec2 vR;

        void main()
        {
        
            

        
            float color = vColor;
            vec2 r = vR;

            vec3 color1 = mix(vec3(0.,0.6,0.7),vec3(0.4,0.1,0.2),color);
            vec3 color2 = mix(vec3(.7,.1,.3),vec3(.6,.9,.9),length(r));
            vec3 colorBands = smoothstep(0.8,1.0,color1);
            vec3 color3 = mix(color1,vec3(0.9,0.8,0.2),r.x);
            vec3 color4 = mix(color3,color2*colorBands,color/4.);

            gl_FragColor = vec4(color4*color2*2.+colorBands, 1.0); //just taking vec3(color) gives nice black/white version
            //gl_FragColor = vec4(vec3(color), 1.0);
        }
    </script>
    
    
    
    
    <script id="vertexShader4" type="x-shader/x-vertex">

        #define M_PI 3.1415926535897932384626433832795

        varying vec3 vNormal;
        varying vec2 vUv;
        varying vec4 vReflection;
        varying float vColor;
        varying vec2 vR;
        uniform float time;
        uniform vec2 mouse;
        uniform vec2 resolution;
        uniform float scale;
        
        
        
        
        
        
        
        //  Simplex 3D Noise Function
    //  by Ian McEwan, Ashima Arts
    //
    vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
    vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

    float noise(vec3 v){ 
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

    // First corner
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;

    // Other corners
      vec3 g = step(x0.yzx, x0.xyz);
      vec3 l = 1.0 - g;
      vec3 i1 = min( g.xyz, l.zxy );
      vec3 i2 = max( g.xyz, l.zxy );

      //  x0 = x0 - 0. + 0.0 * C 
      vec3 x1 = x0 - i1 + 1.0 * C.xxx;
      vec3 x2 = x0 - i2 + 2.0 * C.xxx;
      vec3 x3 = x0 - 1. + 3.0 * C.xxx;

    // Permutations
      i = mod(i, 289.0 ); 
      vec4 p = permute( permute( permute( 
                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
               + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
               + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

    // Gradients
    // ( N*N points uniformly over a square, mapped onto an octahedron.)
      float n_ = 1.0/7.0; // N=7
      vec3  ns = n_ * D.wyz - D.xzx;

      vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

      vec4 x_ = floor(j * ns.z);
      vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

      vec4 x = x_ *ns.x + ns.yyyy;
      vec4 y = y_ *ns.x + ns.yyyy;
      vec4 h = 1.0 - abs(x) - abs(y);

      vec4 b0 = vec4( x.xy, y.xy );
      vec4 b1 = vec4( x.zw, y.zw );

      vec4 s0 = floor(b0)*2.0 + 1.0;
      vec4 s1 = floor(b1)*2.0 + 1.0;
      vec4 sh = -step(h, vec4(0.0));

      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

      vec3 p0 = vec3(a0.xy,h.x);
      vec3 p1 = vec3(a0.zw,h.y);
      vec3 p2 = vec3(a1.xy,h.z);
      vec3 p3 = vec3(a1.zw,h.w);

    //Normalise gradients
      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
      p0 *= norm.x;
      p1 *= norm.y;
      p2 *= norm.z;
      p3 *= norm.w;

    // Mix final noise value
      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
      m = m * m;
      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                    dot(p2,x2), dot(p3,x3) ) );
    }

    #define NUM_OCTAVES 2

    float fbm(vec3 x) {
        float v = 0.0;
        float a = 0.5;
        vec3 shift = vec3(100);
        for (int i = 0; i < NUM_OCTAVES; ++i) {
            v += a * noise(x);
            x = x * 2.0 + shift;
            a *= 0.5;
        }
        return v;
    }
    
    mat2 rotate2d(in float _angle) {
        return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle));
    }
        
        
        
        
        

        // fbm based on 3d space not uv
      
        void main()	{
            vUv = uv / 2.0;
            
            vec2 st = vUv.xy;
            
            vec3 npos = position / 2.;
            npos = clamp(npos,-0.999,.999);
            
            vec2 q = vec2( fbm(npos + time/4.), fbm(npos) );
            vec2 r = vec2( fbm(npos - time/4.), fbm(npos + time/3.) );
            float color = fbm(npos + time/4.);
            vColor = color;
            vR = r;
            
            vec3 normVal = normalize(position);
            
            
            vec3 displacement = normVal*vec3((vColor) + 3.0) + normVal*sin(position.x*position.y*M_PI/4. + time)*sin(position.z*position.y*M_PI/4. + time*.8)*sin(position.z*position.x*M_PI/4. + time*.72);
            
            vec3 newPosition = position + displacement;
            
            vColor += 0.2*fbm(npos*10. + time/3.0);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
        }

		</script>
    
	<script  src="./js/main.js"></script>
</body>
</html>
